#include <stdio.h>
#include "../include/raylib.h"
#include "../include/raymath.h"
typedef struct {
    Vector3 position;
    Vector3 velocity;
    Vector3 lastSafePosition;
    float radius;
    float halfHeight;
    bool isOnGround;
} CollisionCapsule;
typedef struct {
    CollisionCapsule collisionCapsule;
    Vector3 wishDirection;
    float moveSpeed;
} Player;
typedef struct {
    Camera3D rawCamera;
    Vector3 forward;
    Vector3 right;
    Vector3 targetPosition;
} PlayerCamera;
typedef struct {
    Vector3 v0, v1, v2;
    Vector3 normal;
} Triangle;
const float GRAVITY = 9.81f;
const float JUMP_POWER = 8.0f;
const Color DEFUALT_PLAYER_COLOR = {255, 255, 255, 255};
const Color LOVELY_COLOR = {62, 70, 55, 255}; 
const float PLAYER_RADIUS = 1.5f;
const float PLAYER_HEIGHT = 1.0f;
Vector2 inputDirection;
int renderWidth = 320;
int renderHeight = 240;
int screenWidth = 1366;
int screenHeight = 768;
RenderTexture2D renderTarget;
Player player;
PlayerCamera camera;
Model playerModel;
Model levelModel;
Matrix levelTransform;
Vector2 GetInputDirection(void) {
    Vector2 direction = {
        IsKeyDown(KEY_D) - IsKeyDown(KEY_A),
        IsKeyDown(KEY_S) - IsKeyDown(KEY_W)
    };
    return direction;
}
float WrapAngle(float a) {
    while (a > PI) a -= PI*2.0f;
    while (a < -PI) a += PI*2.0f;
    return a;
}
float LerpAngle(float a, float b, float t) {
    float diff = WrapAngle(b - a);
    return a + diff * t;
}
void ComputeRenderResolutionForWindowAspect(
    int windowPixelWidth,
    int windowPixelHeight,
    int fixedRenderPixelHeight,
    int* outRenderPixelWidth,
    int* outRenderPixelHeight
) {
    float windowAspectRatio = (float)windowPixelWidth / (float)windowPixelHeight;
    *outRenderPixelHeight = fixedRenderPixelHeight;
    *outRenderPixelWidth = (int)((float)fixedRenderPixelHeight * windowAspectRatio);
}
Vector3 ClosestPointOnLineSegment(Vector3 a, Vector3 b, Vector3 point) {
    Vector3 ab = Vector3Subtract(b, a);
    float t = Vector3DotProduct(Vector3Subtract(point, a), ab) / Vector3DotProduct(ab, ab);
    t = fmaxf(0.0f, fminf(1.0f, t));
    return Vector3Add(a, Vector3Scale(ab, t));
}
bool IsPointInTriangle(Vector3 point, Triangle tri) {
    Vector3 v0 = Vector3Subtract(tri.v2, tri.v0);
    Vector3 v1 = Vector3Subtract(tri.v1, tri.v0);
    Vector3 v2 = Vector3Subtract(point, tri.v0);
    float dot00 = Vector3DotProduct(v0, v0);
    float dot01 = Vector3DotProduct(v0, v1);
    float dot02 = Vector3DotProduct(v0, v2);
    float dot11 = Vector3DotProduct(v1, v1);
    float dot12 = Vector3DotProduct(v1, v2);
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v <= 1);
}
Triangle GetTriangle(Mesh mesh, Matrix transform, int triIndex) {
    Triangle tri = {0};
    Vector3 v0, v1, v2;
    if (mesh.indices) {
        if (triIndex * 3 + 2 >= mesh.triangleCount * 3) {
            return tri;
        }
        int i0 = mesh.indices[triIndex * 3 + 0];
        int i1 = mesh.indices[triIndex * 3 + 1];
        int i2 = mesh.indices[triIndex * 3 + 2];
        v0 = (Vector3){ mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2] };
        v1 = (Vector3){ mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2] };
        v2 = (Vector3){ mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2] };
    } else {
        if (triIndex * 9 + 8 >= mesh.vertexCount * 3) {
            return tri;
        }
        int baseIdx = triIndex * 9; // 3 vertices * 3 floats each
        v0 = (Vector3){ mesh.vertices[baseIdx], mesh.vertices[baseIdx+1], mesh.vertices[baseIdx+2] };
        v1 = (Vector3){ mesh.vertices[baseIdx+3], mesh.vertices[baseIdx+4], mesh.vertices[baseIdx+5] };
        v2 = (Vector3){ mesh.vertices[baseIdx+6], mesh.vertices[baseIdx+7], mesh.vertices[baseIdx+8] };
    }
    tri.v0 = Vector3Transform(v0, transform);
    tri.v1 = Vector3Transform(v1, transform);
    tri.v2 = Vector3Transform(v2, transform);
    Vector3 edge1 = Vector3Subtract(tri.v1, tri.v0);
    Vector3 edge2 = Vector3Subtract(tri.v2, tri.v0);
    tri.normal = Vector3Normalize(Vector3CrossProduct(edge1, edge2));
    return tri;
}
bool TestCapsuleTriangle(Vector3* position, Vector3 capsuleBase, Vector3 capsuleTop, float radius, Triangle tri, Vector3* pushOut) {
    Vector3 closestOnCapsule = ClosestPointOnLineSegment(capsuleBase, capsuleTop, tri.v0);
    float distanceToPlane = Vector3DotProduct(Vector3Subtract(closestOnCapsule, tri.v0), tri.normal);
    if (fabsf(distanceToPlane) > radius) {
        return false;
    }
    Vector3 pointOnPlane = Vector3Subtract(closestOnCapsule, Vector3Scale(tri.normal, distanceToPlane));
    if (IsPointInTriangle(pointOnPlane, tri)) {
        if (fabsf(distanceToPlane) < radius) {
            float penetration = radius - fabsf(distanceToPlane);
            float direction = distanceToPlane >= 0 ? 1.0f : -1.0f;
            *pushOut = Vector3Scale(tri.normal, penetration * direction);
            return true;
        }
    }
    return false;
}
float FindFloor(Vector3 pos, Vector3* outNormal) {
    float highestFloor = -10000.0f;
    Vector3 floorNormal = {0, 1, 0};
    bool foundFloor = false;
    for (int meshIdx = 0; meshIdx < levelModel.meshCount; meshIdx++) {
        Mesh mesh = levelModel.meshes[meshIdx];
        int triangleCount = mesh.triangleCount;
        if (triangleCount == 0) {
            triangleCount = mesh.vertexCount / 3;
        }
        for (int i = 0; i < triangleCount; i++) {
            Triangle tri = GetTriangle(mesh, levelTransform, i);
            if (Vector3LengthSqr(tri.normal) < 0.001f) continue;
            if (tri.normal.y <= 0.5f) continue;
            Vector3 testPoint = pos;
            testPoint.y = tri.v0.y;
            if (IsPointInTriangle(testPoint, tri)) {
                // Calculate exact height at this point
                // Plane equation: nÂ·(p - p0) = 0
                // For floor: p.y = p0.y - (n.x*(p.x-p0.x) + n.z*(p.z-p0.z)) / n.y
                float height = 
                    tri.v0.y - 
                    (tri.normal.x*(testPoint.x - tri.v0.x) + 
                    tri.normal.z*(testPoint.z - tri.v0.z)) / 
                    tri.normal.y;
                if (height > highestFloor && height <= pos.y + 100.0f) {
                    highestFloor = height;
                    floorNormal = tri.normal;
                    foundFloor = true;
                }
            }
        }
    }
    *outNormal = floorNormal;
    return foundFloor ? highestFloor : -10000.0f;
}
int ResolveCapsuleCollision(Vector3* position, float radius, float height) {
    int collisionCount = 0;
    Vector3 capsuleBase = *position;
    Vector3 capsuleTop = Vector3Add(*position, (Vector3){0, height, 0});
    for (int meshIdx = 0; meshIdx < levelModel.meshCount; meshIdx++) {
        Mesh mesh = levelModel.meshes[meshIdx];
        int triangleCount = mesh.triangleCount;
        if (triangleCount == 0) { triangleCount = mesh.vertexCount / 3; }
        for (int i = 0; i < triangleCount; i++) {
            Triangle tri = GetTriangle(mesh, levelTransform, i);
            if (Vector3LengthSqr(tri.normal) < 0.001f) continue;
            if (tri.normal.y > 0.7f) continue;
            Vector3 pushOut = {0, 0, 0};
            if (TestCapsuleTriangle(position, capsuleBase, capsuleTop, radius, tri, &pushOut)) {
                position->x += pushOut.x;
                position->y += pushOut.y;
                position->z += pushOut.z;
                capsuleBase = *position;
                capsuleTop = Vector3Add(*position, (Vector3){0, height, 0});
                collisionCount++;
            }
        }
    }
    return collisionCount;
}
void PlayerInitialize(void) {
    camera = (PlayerCamera){
        .rawCamera = (Camera3D){
            .position = {0.0f, 3.0f, 5.0f},
            .target = {0.0f, 0.0f, 0.0f},
            .up = {0.0f, 1.0f, 0.0f},
            .fovy = 90.0f, 
            .projection = CAMERA_PERSPECTIVE 
        },
        .forward = (Vector3){0.0f, 0.0f, 0.0f},
        .right = (Vector3){0.0f, 0.0f, 0.0f},
        .targetPosition = (Vector3){0.0f, 0.0f, 0.0f}
    };
    player = (Player){
        .collisionCapsule = (CollisionCapsule){
            .position = {0.0f, 5.0f, 0.0f},
            .velocity = {0.0f, 0.0f, 0.0f},
            .lastSafePosition = {0.0f, 5.0f, 0.0f},
            .radius = PLAYER_RADIUS,
            .halfHeight = PLAYER_HEIGHT / 2.0f,
            .isOnGround = false
        },
        .wishDirection = (Vector3){0.0f, 0.0f, 0.0f},
        .moveSpeed = 5.0f
    };
    playerModel = LoadModel("assets/ShadowSlink.gltf");
}
void PlayerUpdate(Player* player, PlayerCamera* camera, float delta) {
    CollisionCapsule *pCollider = &player->collisionCapsule;
    if (!pCollider->isOnGround) { pCollider->velocity.y -= GRAVITY * delta; }
    if (pCollider->isOnGround && IsKeyDown(KEY_SPACE)) {
        pCollider->velocity.y = JUMP_POWER;
        pCollider->isOnGround = false;
    }
    Vector3 horizontalVelocity = {
        player->wishDirection.x * player->moveSpeed,
        0,
        player->wishDirection.z * player->moveSpeed
    };
    pCollider->position.x += horizontalVelocity.x * delta;
    pCollider->position.z += horizontalVelocity.z * delta;
    for (int i = 0; i < 3; i++) {
        int walls = ResolveCapsuleCollision(&pCollider->position, pCollider->radius, PLAYER_HEIGHT);
        if (walls == 0) break;
    }
    pCollider->position.y += pCollider->velocity.y * delta;
    Vector3 floorNormal;
    float floorHeight = FindFloor(pCollider->position, &floorNormal);
    if (floorHeight > -9999.0f) {
        float distToFloor = pCollider->position.y - floorHeight;
        if (distToFloor <= 0.1f && pCollider->velocity.y <= 0) {
            pCollider->position.y = floorHeight;
            pCollider->velocity.y = 0;
            pCollider->isOnGround = true;
        } else {
            pCollider->isOnGround = false;
        }
    }
    if (pCollider->position.y < -20) { pCollider->position = (Vector3){0, 5, 0}; }
}
void DrawPlayer(Model playerModel, Vector3 position, Vector3 wishDirection) {
    static float yaw = 0.0f;
    static float targetYaw = 0.0f;
    if (Vector3LengthSqr(wishDirection) > 0.0001f) {
        wishDirection = Vector3Normalize(wishDirection);
        targetYaw = atan2f(-wishDirection.x, -wishDirection.z);
    }
    float turnSpeed = 8.0f * GetFrameTime();
    yaw = LerpAngle(yaw, targetYaw, turnSpeed);
    DrawModelEx(
        playerModel,
        position,
        (Vector3){ 0, 1, 0 },
        yaw * RAD2DEG,
        (Vector3){ 1, 1, 1 },
        WHITE
    );
    Vector3 bottom = Vector3Add(position, (Vector3){0, player.collisionCapsule.radius, 0});
    Vector3 top = Vector3Add(bottom, (Vector3){0, player.collisionCapsule.halfHeight * 2.0f - player.collisionCapsule.radius*2.0f, 0});
    DrawCapsuleWires(bottom, top, player.collisionCapsule.radius, 6, 4, WHITE);
}
int main(void) {
    InitWindow(screenWidth, screenHeight, "Coward 3D!");
    ComputeRenderResolutionForWindowAspect(
        screenWidth,
        screenHeight,
        renderHeight,
        &renderWidth,
        &renderHeight
    );
    renderTarget = LoadRenderTexture(renderWidth, renderHeight);
    SetTextureFilter(renderTarget.texture, TEXTURE_FILTER_POINT);
    PlayerInitialize();
    levelModel = LoadModel("assets/Bogmire Arena/bogmire-arena.obj");
    levelTransform = MatrixScale(2.0f, 2.0f, 2.0f);
    SetTargetFPS(0);
    while (!WindowShouldClose()) {
        float delta = GetFrameTime();
        inputDirection = GetInputDirection();
        camera.targetPosition = Vector3Add(player.collisionCapsule.position, (Vector3){0.0f, player.collisionCapsule.halfHeight, 0.0f});
        camera.rawCamera.position = Vector3Add(camera.targetPosition, (Vector3){0.0f, 4, 5.0f});
        camera.rawCamera.target = Vector3Lerp(camera.rawCamera.target, player.collisionCapsule.position, 0.01f * delta); 
        camera.forward = Vector3Subtract(camera.rawCamera.position, camera.rawCamera.target);
        camera.forward.y = 0;
        camera.forward = Vector3Normalize(camera.forward);
        camera.right = Vector3CrossProduct(camera.rawCamera.up, camera.forward);
        camera.right = Vector3Normalize(camera.right);
        player.wishDirection = Vector3Normalize(Vector3Add(
            Vector3Scale(camera.forward, inputDirection.y), 
            Vector3Scale(camera.right, inputDirection.x)
        ));
        PlayerUpdate(&player, &camera, delta);
        BeginTextureMode(renderTarget);
            ClearBackground(LOVELY_COLOR);
            BeginMode3D(camera.rawCamera);
                DrawGrid(40, 4.0f);
                DrawCube(player.collisionCapsule.position, 1, 1, 1, RED);
                DrawPlayer(playerModel, player.collisionCapsule.position, player.wishDirection);
                DrawModel(levelModel, (Vector3){0.0f, 0.0f, 0.0f}, 2.0f, WHITE);
            EndMode3D();
        EndTextureMode();
        BeginDrawing();
            Rectangle sourceRenderTextureRect = {
                0.0f, 0.0f,
                (float)renderTarget.texture.width,
                -(float)renderTarget.texture.height
            };
            float renderToWindowScale = fminf(
                (float)screenWidth  / (float)renderWidth,
                (float)screenHeight / (float)renderHeight
            );
            Rectangle destinationWindowRect = {
                (screenWidth  - (renderWidth  * renderToWindowScale)) * 0.5f,
                (screenHeight - (renderHeight * renderToWindowScale)) * 0.5f,
                renderWidth  * renderToWindowScale,
                renderHeight * renderToWindowScale
            };
            DrawTexturePro(
                renderTarget.texture,
                sourceRenderTextureRect,
                destinationWindowRect,
                (Vector2){ 0.0f, 0.0f },
                0.0f,
                WHITE
            );
            DrawFPS(10, 10);
        EndDrawing();
    }
    UnloadRenderTexture(renderTarget);
    CloseWindow();
    return 0;
}
